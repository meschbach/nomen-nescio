<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
		<script src="js/three.min.js"></script>
		<script>
//http://threejs.org/docs/index.html#Manual/Introduction/Creating_a_scene
	var preRender = [];
		function init(){
			var sys = {
				visuals: init_gl(),
				sim: init_simulation( )
			};
			init_player( sys );

			var otherCraft = {
				forwardThrust: 0.005
			};
		}

		function init_player( sys ){
			var visuals = sys.visuals;
			var sim = sys.sim;

			var player = {
				momentum: { x: 0, y: 0, z: 0 },
				position: { x: 0, y: 0, z: 5 },
				animate_tick: function(){
					var camera = visuals.camera;
					camera.position.x = this.position.x;
					camera.position.y = this.position.y;
					camera.position.z = this.position.z;
				},
				simulation_tick: function(){
					this.position.x += this.momentum.x;
					this.position.y += this.momentum.y;
					this.position.z += this.momentum.z;
				}
			};
			visuals.animatable.push( player );
			sys.sim.simulate.push(  player );
			var primary_thruster = thrust_aspect( sys, player, { x: 0, y: 0, z: -1 } );
			var top_nav_thruster = thrust_aspect( sys, player, { x: 0, y: 1, z: 0 } );
			var bottom_nav_thruster = thrust_aspect( sys, player, { x: 0, y: -1, z: 0 } );

			window.addEventListener( "keydown", function( k ){
				var c = String.fromCharCode( k.keyCode );
				console.log( c );
				switch( c ){
					case 'R':
						top_nav_thruster.increase();
						break;
					case 'Z':
						bottom_nav_thruster.increase();
						break;
					case 'W':
						primary_thruster.increase();
						break;
					case 'S':
						primary_thruster.decrease();
						break;
				}
			});
		}

		function thrust_aspect( sys, object, vector ){
			var thruster = {
				step: 0.01,
				maximum: 0.4,
				minimum: -0.4,
				thrust: 0,
				vector: vector,
				simulation_tick: function(){
					//TODO thrust
					object.momentum.x += this.vector.x * this.thrust;
					object.momentum.y += this.vector.y * this.thrust;
					object.momentum.z += this.vector.z * this.thrust;
				},
				increase: function(){
					var more = this.thrust + this.step;
					if( more < this.maximum ){
						this.thrust = more;
					}
				},
				decrease: function(){
					var less = this.thrust - this.step;
					if( less > this.minimum ){
						this.thrust = less;
					}
				}
			};
			sys.sim.simulate.push( thruster );
			return thruster;
		}

		function init_simulation( visuals /* don't really belong here */ ){
			var tickables = [];
			function game_tick(){
				tickables.forEach( function( t ) { t.simulation_tick(); } );
			}

			setInterval( game_tick, 1000 / 60 );
			return { simulate: tickables };
		}

			function init_gl(){
				var scene = new THREE.Scene();
				var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

				var renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				var geometry = new THREE.BoxGeometry( 1, 1, 1 );
				var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
				var cube = new THREE.Mesh( geometry, material );
				scene.add( cube );

				camera.position.z = 5;

				var animatables = [];
				var render = function () {
					requestAnimationFrame( render );

					animatables.forEach( function( visual ){
						visual.animate_tick();
					});

					renderer.render(scene, camera);
				};

				render();
				return {
					camera: camera,
					cube: cube,
					animatable: animatables
				};
			}
		</script>
	</head>
	<body onload='init()'>
	</body>
</html>
